
# 📘 Accessing HTML Elements in Angular

## 🏷 Template Reference Variable (`#`)

* In an HTML template, you can use `#` to create a **reference** to an element.
* This reference can be used:

  * **Directly in the template** (binding, event handling).
  * Or **inside TypeScript code** via `@ViewChild()`.

Example:

```html
<!-- user.component.html -->
<input type="text" #userInput placeholder="Enter your name">
<button (click)="showInput(userInput.value)">Show</button>
```

```ts
// user.component.ts
showInput(value: string) {
  console.log('User entered:', value);
}
```

👉 Here, `#userInput` is a **template reference variable**, and we use it directly in HTML.

---

## 🛠 Using `@ViewChild()` with `ElementRef`

* `@ViewChild()` is used to **access a single DOM element or Angular child component**.
* It works with the template reference variable (`#name`).
* `ElementRef` is a wrapper around the **native DOM element**.

```ts
// user.component.ts
import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html'
})
export class UserComponent implements AfterViewInit {
  @ViewChild('userInput', { static: false }) userInput!: ElementRef;

  ngAfterViewInit() {
    console.log('Input element:', this.userInput.nativeElement);
  }

  getInput() {
    console.log('Input Value:', this.userInput.nativeElement.value);
  }
}
```

```html
<!-- user.component.html -->
<input type="text" #userInput placeholder="Type something">
<button (click)="getInput()">Log Input</button>
```

👉 `this.userInput.nativeElement.value` gives the text entered.

---

## 👨‍👩‍👧 Using `@ViewChildren()` (Multiple Elements)

* When you need to **access multiple DOM elements or components**, use `@ViewChildren()`.
* It returns a **QueryList**, which behaves like an array.

```ts
import { Component, ViewChildren, QueryList, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-user-list',
  templateUrl: './user-list.component.html'
})
export class UserListComponent implements AfterViewInit {
  @ViewChildren('userInput') userInputs!: QueryList<ElementRef>;

  ngAfterViewInit() {
    this.userInputs.forEach((input, index) => {
      console.log(`Input ${index + 1}:`, input.nativeElement);
    });
  }
}
```

```html
<!-- user-list.component.html -->
<input type="text" #userInput placeholder="User 1">
<input type="text" #userInput placeholder="User 2">
<input type="text" #userInput placeholder="User 3">
```

👉 `@ViewChildren()` gives all elements marked with `#userInput`.

---

## 🔄 Lifecycle Hook: `AfterViewInit`

* `@ViewChild()` and `@ViewChildren()` references are **only available after the view is initialized**.
* That’s why we use the **`AfterViewInit`** lifecycle hook.

```ts
import { AfterViewInit } from '@angular/core';

export class UserComponent implements AfterViewInit {
  ngAfterViewInit() {
    console.log('View is ready! You can now access DOM elements.');
  }
}
```

---

## ⚡ Real-life Example

Imagine a **bulk attendance form** in HRMS:

```html
<input type="checkbox" #empCheck> Employee 1
<input type="checkbox" #empCheck> Employee 2
<input type="checkbox" #empCheck> Employee 3
<button (click)="getSelected()">Submit</button>
```

```ts
@ViewChildren('empCheck') empChecks!: QueryList<ElementRef>;

getSelected() {
  const selected = this.empChecks
    .filter(c => c.nativeElement.checked)
    .map(c => c.nativeElement.nextSibling.textContent.trim());

  console.log('Selected Employees:', selected);
}
```

👉 Allows you to collect all checked employees at once.

---

## 🚨 Best Practices

* ✅ Use `@ViewChild` / `@ViewChildren` only when necessary.
* ✅ Prefer **Angular data binding** for most cases.
* ⚠️ Direct DOM manipulation (`ElementRef.nativeElement`) can break Angular’s security (XSS risks).
* ✅ Use Angular’s `Renderer2` service for **safe DOM changes**.

---

